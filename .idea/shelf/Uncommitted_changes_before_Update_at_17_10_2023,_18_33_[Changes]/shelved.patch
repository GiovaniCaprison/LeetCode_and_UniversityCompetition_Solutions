Index: Validate_Binary_Tree_Nodes.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>class Validate_Binary_Tree_Nodes {\n    // This array will be used to represent the parent of each node.\n    private int[] parent;\n\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\n        // Initialize parent array so that each node is its own parent (standard union-find initialization)\n        parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n\n        // Check edges between each node and its children.\n        int edges = 0;\n        for (int i = 0; i < n; i++) {\n            // If there's an issue with the left or right child, return false.\n            if (!processEdge(i, leftChild[i])) return false;\n            if (!processEdge(i, rightChild[i])) return false;\n        }\n\n        // A valid tree with 'n' nodes should have exactly 'n-1' edges.\n        if (edges != n - 1) return false;\n\n        // Count how many nodes act as their own parent, i.e., are roots of their trees.\n        int rootCount = 0;\n        for (int i = 0; i < n; i++) {\n            if (parent[i] == i) rootCount++;\n        }\n\n        // A valid tree should have exactly one root.\n        return rootCount == 1;\n    }\n\n    private boolean processEdge(int node, int child) {\n        // If the child does not exist (represented by -1), there's nothing to process.\n        if (child == -1) return true;\n\n        // If the child already has a different parent, it's an invalid tree.\n        if (parent[child] != child) return false;\n\n        // Set the parent of the child to be the current node.\n        parent[child] = node;\n\n        // Check for cycles: If the node and its child belong to the same set, we have a cycle.\n        if (find(node) == find(child)) return false;\n\n        // Merge the sets of the node and its child.\n        union(node, child);\n\n        return true;\n    }\n\n    // 'find' function for union-find: It returns the root of the tree the node belongs to.\n    private int find(int x) {\n        // If the node is not its own parent, recursively find its root.\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    // 'union' function for union-find: Merges the sets of x and y.\n    private void union(int x, int y) {\n        int rootX = find(x);  // Find root of x\n        int rootY = find(y);  // Find root of y\n\n        // If x and y are in different sets, make one of them the parent of the other.\n        if (rootX != rootY) {\n            parent[rootY] = rootX;\n        }\n    }\n}\n\n
===================================================================
diff --git a/Validate_Binary_Tree_Nodes.java b/Validate_Binary_Tree_Nodes.java
--- a/Validate_Binary_Tree_Nodes.java	
+++ b/Validate_Binary_Tree_Nodes.java	
@@ -1,72 +1,57 @@
-class Validate_Binary_Tree_Nodes {
-    // This array will be used to represent the parent of each node.
-    private int[] parent;
-
+class Solution {
     public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {
-        // Initialize parent array so that each node is its own parent (standard union-find initialization)
-        parent = new int[n];
+        int[] hasParent = new int[n];
+        boolean[] hasCycle = new boolean[n];
+
+        // Initialize all nodes to have no parent.
         for (int i = 0; i < n; i++) {
-            parent[i] = i;
+            hasParent[i] = -1;
         }
 
-        // Check edges between each node and its children.
-        int edges = 0;
         for (int i = 0; i < n; i++) {
-            // If there's an issue with the left or right child, return false.
-            if (!processEdge(i, leftChild[i])) return false;
-            if (!processEdge(i, rightChild[i])) return false;
+            if (leftChild[i] != -1) {
+                // If the child already has a parent, it's an invalid tree.
+                if (hasParent[leftChild[i]] != -1) return false;
+                hasParent[leftChild[i]] = i;
+            }
+            if (rightChild[i] != -1) {
+                if (hasParent[rightChild[i]] != -1) return false;
+                hasParent[rightChild[i]] = i;
+            }
         }
 
-        // A valid tree with 'n' nodes should have exactly 'n-1' edges.
-        if (edges != n - 1) return false;
-
-        // Count how many nodes act as their own parent, i.e., are roots of their trees.
-        int rootCount = 0;
+        // Find the root.
+        int count = 0;
+        int root = -1;
         for (int i = 0; i < n; i++) {
-            if (parent[i] == i) rootCount++;
-        }
-
-        // A valid tree should have exactly one root.
-        return rootCount == 1;
-    }
+            if (hasParent[i] == -1) {
+                count++;
+                root = i;
+            }
+        }
 
-    private boolean processEdge(int node, int child) {
-        // If the child does not exist (represented by -1), there's nothing to process.
-        if (child == -1) return true;
-
-        // If the child already has a different parent, it's an invalid tree.
-        if (parent[child] != child) return false;
+        // There should be only one root.
+        if (count != 1) return false;
 
-        // Set the parent of the child to be the current node.
-        parent[child] = node;
+        // BFS traversal
+        Queue<Integer> q = new LinkedList<>();
+        q.add(root);
+        while (!q.isEmpty()) {
+            int temp = q.poll();
+            if (hasCycle[temp]) return false; // If we've seen the node before, it's a cycle.
+            hasCycle[temp] = true;
 
-        // Check for cycles: If the node and its child belong to the same set, we have a cycle.
-        if (find(node) == find(child)) return false;
+            if (leftChild[temp] != -1) q.add(leftChild[temp]);
+            if (rightChild[temp] != -1) q.add(rightChild[temp]);
+        }
 
-        // Merge the sets of the node and its child.
-        union(node, child);
+        // Check if all nodes are visited
+        for (int i = 0; i < n; i++) {
+            if (!hasCycle[i]) return false;
+        }
 
         return true;
     }
-
-    // 'find' function for union-find: It returns the root of the tree the node belongs to.
-    private int find(int x) {
-        // If the node is not its own parent, recursively find its root.
-        if (parent[x] != x) {
-            parent[x] = find(parent[x]);
-        }
-        return parent[x];
-    }
-
-    // 'union' function for union-find: Merges the sets of x and y.
-    private void union(int x, int y) {
-        int rootX = find(x);  // Find root of x
-        int rootY = find(y);  // Find root of y
+}
 
-        // If x and y are in different sets, make one of them the parent of the other.
-        if (rootX != rootY) {
-            parent[rootY] = rootX;
-        }
-    }
-}
 
